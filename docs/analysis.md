**Tο πρόγραμμα λειτουργεί σαν ένας αυτόματος επεξεργαστής κειμένου που διορθώνει, μορφοποιεί και συμπληρώνει ένα αρχείο σύμφωνα με προκαθορισμένους κανόνες. διαβάζει ένα αρχείο εισόδου, αναλύει το περιεχόμενό του λέξη προς λέξη και ψάχνει για ειδικές σημάνσεις μέσα στο κείμενο όπως (hex), (bin), (up), (low), (cap) ή ακόμα και σύνθετες μορφές όπως (up, 2). κάθε μία από αυτές τις σημάνσεις δηλώνει μια συγκεκριμένη ενέργεια που πρέπει να εφαρμοστεί στην προηγούμενη λέξη ή στις προηγούμενες n λέξεις. για παράδειγμα, όταν το πρόγραμμα συναντήσει “(hex)”, μετατρέπει τον προηγούμενο δεκαεξαδικό αριθμό στη δεκαδική του τιμή, ενώ το “(bin)” κάνει το ίδιο για δυαδικούς αριθμούς. οι οδηγίες (up), (low) και (cap) μετατρέπουν τη λέξη ή τις λέξεις πριν από αυτές σε κεφαλαία, πεζά ή κεφαλαιοποιημένα αντίστοιχα.**

**εκτός από τις μετατροπές λέξεων, το πρόγραμμα φροντίζει και για τη σωστή τοποθέτηση της στίξης, εξασφαλίζοντας ότι σημεία όπως τελείες, κόμματα και θαυμαστικά είναι κολλημένα στη λέξη που προηγείται και έχουν ένα κενό μετά. ειδικές περιπτώσεις όπως “...” ή “\!?” αναγνωρίζονται ως ενιαία σύνολα και δεν χωρίζονται. επίσης, χειρίζεται σωστά τα εισαγωγικά τύπου ‘ ’, τοποθετώντας τα χωρίς κενά γύρω από το περιεχόμενο που περικλείουν. τέλος, υπάρχει και ένας κανόνας γραμματικής: όταν η λέξη “a” προηγείται από λέξη που ξεκινά με φωνήεν ή με “h”, αντικαθίσταται αυτόματα από “an”, ώστε το κείμενο να είναι σωστό συντακτικά.**

**μετά την εφαρμογή όλων αυτών των κανόνων, το πρόγραμμα επανασυνθέτει το τελικό κείμενο και το αποθηκεύει στο αρχείο εξόδου. στην ουσία, λειτουργεί ως ένας απλός αλλά “έξυπνος” διορθωτής που μετατρέπει ένα ακατέργαστο κείμενο σε μια σωστά μορφοποιημένη και τυποποιημένη εκδοχή του, διορθώνοντας αριθμούς, μορφοποίηση, κεφαλαία/πεζά, στίξη και βασικούς γραμματικούς κανόνες .**

**Κανόνας (hex):**  
 Όταν μια λέξη ακολουθείται από τον δείκτη (hex), η λέξη αυτή θεωρείται δεκαεξαδικός αριθμός και αντικαθίσταται από την δεκαδική της τιμή.  
 Παράδειγμα 1: "1E (hex) files were added" → "30 files were added"  
 Παράδειγμα 2: "FF (hex) colors available" → "255 colors available"  
 Παράδειγμα 3: "0A (hex) equals ten" → "10 equals ten"

**Κανόνας (bin):**  
 Αντίστοιχα, όταν μια λέξη ακολουθείται από τον δείκτη (bin), η λέξη ερμηνεύεται ως δυαδικός αριθμός και αντικαθίσταται από την δεκαδική τιμή του.  
 Παράδειγμα 1: "10 (bin) people came" → "2 people came"  
 Παράδειγμα 2: "1010 (bin) apples" → "10 apples"  
 Παράδειγμα 3: "1111 (bin) lights" → "15 lights"

**Κανόνας (up):**  
 Η οδηγία (up) μετατρέπει τη λέξη που προηγείται σε κεφαλαία γράμματα.  
 Παράδειγμα 1: "this is fun (up)" → "this is FUN"  
 Παράδειγμα 2: "ready set go (up)" → "ready set GO"  
 Παράδειγμα 3: "watch out (up)" → "watch OUT"

**Κανόνας (low):**  
 Η οδηγία (low) μετατρέπει τη λέξη που προηγείται σε πεζά. Αν υπάρχει αριθμός μέσα στην παρένθεση, εφαρμόζεται στις αντίστοιχες προηγούμενες λέξεις.  
 Παράδειγμα 1: "STOP YELLING (low)" → "stop yelling"  
 Παράδειγμα 2: "HELLO WORLD (low, 2)" → "hello world"  
 Παράδειγμα 3: "SHOUT Less (low, 1)" → "shout Less"

**Κανόνας (cap):**  
 Η οδηγία (cap) κεφαλαιοποιεί την πρώτη λέξη ή όσες καθορίζονται από αριθμό μετά το κόμμα.  
 Παράδειγμα 1: "the brooklyn bridge (cap)" → "The Brooklyn Bridge"  
 Παράδειγμα 2: "good morning (cap, 2)" → "Good Morning"  
 Παράδειγμα 3: "let’s go to paris (cap, 3)" → "Let’s Go To Paris"

**Κανόνας για σημεία στίξης (. , \! ? : ;)**  
 Κάθε σημείο στίξης πρέπει να συνδέεται απευθείας με τη λέξη που προηγείται και να υπάρχει κενό μετά από αυτό. Οι περιπτώσεις πολλαπλών σημείων, όπως "..." ή "\!?", παραμένουν ενωμένες.  
 Παράδειγμα 1: "hello ,world\!" → "hello, world\!"  
 Παράδειγμα 2: "wait ;what ?" → "wait; what?"  
 Παράδειγμα 3: "it’s fine , really \!" → "it’s fine, really\!"

**Κανόνας πολλαπλής στίξης (..., \!?)**  
 Όταν εμφανίζονται πολλαπλά σημεία στίξης, αυτά θεωρούνται ενιαίο σύνολο και παραμένουν χωρίς επιπλέον κενά.  
 Παράδειγμα 1: "I was thinking ... you were right" → "I was thinking... you were right"  
 Παράδειγμα 2: "what \!? are you sure ?" → "what\!? are you sure?"  
 Παράδειγμα 3: "stop ... please" → "stop... please"

**Κανόνας για απόστροφο (‘ ’):**  
 Οι αποστροφοι πρέπει να εφάπτονται στις λέξεις που περικλείουν, χωρίς κενά ανάμεσά τους.  
 Παράδειγμα 1: "I am ' happy '" → "I am 'happy'"  
 Παράδειγμα 2: "He said: ' I am fine '" → "He said: 'I am fine'"  
 Παράδειγμα 3: "They called it ' the big event '" → "They called it 'the big event'"

**Κανόνας για το άρθρο "a" → "an":**  
 Το άρθρο "a" μετατρέπεται σε "an" όταν η επόμενη λέξη ξεκινά με φωνήεν ή με το γράμμα "h".  
 Παράδειγμα 1: "a apple a day" → "an apple a day"  
 Παράδειγμα 2: "a orange on the table" → "an orange on the table"  
 Παράδειγμα 3: "a honest man" → "an honest man"

## 

**Pipeline-Fsm**

Για το project **Go Reloaded** επιλέγω να εργαστώ με **Pipeline αρχιτεκτονική** ως βασική δομή,  
 και να ενσωματώσω **ένα μικρό FSM (Finite State Machine)** μέσα σε ένα από τα στάδια,  
 μόνο για ειδικές περιπτώσεις που χρειάζονται «μνήμη» ή “context” (όπως quotes και σύνθετες εντολές).Η αρχιτεκτονική **Pipeline** σημαίνει ότι το πρόγραμμα λειτουργεί σαν μια **αλυσίδα από Συναρτήσεις**.  
 Κάθε στάδιο παίρνει το κείμενο, κάνει **ένα συγκεκριμένο είδος επεξεργασίας**, και μετά το δίνει στο επόμενο στάδιο.

Για παράδειγμα:

`Input → Clean text → Apply (hex/bin) → Apply (up/low/cap) → Fix punctuation → Output`

Αυτό το μοντέλο είναι **πολύ καθαρό**:

* Μπορώ να δοκιμάζω κάθε στάδιο χωριστά (εύκολο testing).  
* Οι auditors μπορούν να δουν **ξεκάθαρα** ποιο μέρος του κώδικα κάνει τι.  
* Αν κάτι πάει στραβά, ξέρω σε ποιο στάδιο να ψάξω  
* Είναι απλό να το εξηγήσω γραπτά, γιατί κάθε κανόνας αντιστοιχεί σε ένα συγκεκριμένο “βήμα” του pipeline.

Το **FSM (Finite State Machine)** λειτουργεί διαφορετικά:  
 αντί να έχει στάδια, έχει **καταστάσεις** που αλλάζουν ανάλογα με το τι βλέπει το πρόγραμμα και ξερει ακριβώς σε τι κατάσταση είναι κάθε λεπτό.  
 Για παράδειγμα, όταν το πρόγραμμα μπαίνει σε quotes (`'`),  
 μπαίνει σε κατάσταση **INSIDE\_QUOTES**, και εκεί μέσα πρέπει να συμπεριφερθεί αλλιώς:

* να αγνοήσει εξωτερικούς κανόνες,  
* ή να εφαρμόσει εντολές μόνο μέσα στο quote.

Αυτό είναι κάτι που **δεν μπορεί να κάνει εύκολα το Pipeline μόνο του**,  
 γιατί χρειάζεται “μνήμη” — πρέπει να θυμάται *πού βρισκόταν*.Γι’ αυτό, θα επιλέξω **ένα μικρό FSM “μέσα” σε συγκεκριμένο στάδιο** του Pipeline.  
 Π.χ. στο στάδιο “ApplyTextCommands” θα ενσωματώσω έναν μικρό μηχανισμό FSM που ελέγχει:

* αν βρισκόμαστε μέσα σε `'quotes'`

* αν πρέπει να εφαρμόσουμε `(up, N)` σε συγκεκριμένο αριθμό λέξεων

* αν πρέπει να αγνοήσουμε κάτι ή να αλλάξουμε συμπεριφορά

Έτσι, έχω **την απλότητα του Pipeline**, αλλά και **τη “νοημοσύνη” του FSM** όπου χρειάζεται.